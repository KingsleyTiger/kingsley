1.OS의 기능
 1)system call 제공 : 사용자가 여러가지 기능을 사용할 수 있도록 system call을 제공한다.
 2)자원 관리 : 하드웨어의 성능을 위해 메모리,CPU 등의 자원을 효율적으로 관리한다.

2.mechanism과 policy의 차이점
 1)mechanism이란 필요한 기능을 구현한 방법. ex)문맥교환 
 2)정책은 결정을 내리기 위한 알고리즘.무엇을 해야하는가? ex)스케쥴링
 정책을 실현하기 위해서 메커니즘을 사용한다.
 정책은 상황에 따라 변할 수 있지만 메커니즘은 변하면 안된다. 메커니즘이 잘 설계되어 있다면 정책이 바뀌어도메커니즘이 바뀔 일이 없다. 예를 들어 스케쥴링 알고리즘(정책)은 어떤 프로세스를 언제 사용하냐에 따라 다르게 설정된다. 하지만 프로세스를 교체하고, 프로세스의 실행시간을 측정하는 메커니즘은 정책이 바뀌어도 바뀌지 않는다. 따라서 정책과 메커니즘은 분리되어 있어야한다.

3.VA -> PA 변환

4.CPU 가상화란?
하나의 CPU는 하나의 프로세스만 실행할 수 있다. 하지만 여러 개의 프로세스를 실행해야 하는 상황이 존재하고, 그러기 위해서 프로세스를 속여 여러 개의 CPU가 존재해 각자가 실행되고 있는 것처럼 느끼게 하는 것이다.
시분할 방식은 하나의 CPU를 일정 시간동안만 프로세스가 점유할 수 있게 해 여러 프로세스를 동시에 실행하는 방법이다.

5.OS의 디자인 목표
 1)추상화 : 컴퓨터가 행하는 모든 것들이 어떻게 돌아가는지 알지 못해도 운영체제가 제공해주는 것만으로도 실행할 수 있게 해주는 것.
 2)성능 : 문맥교환 비용, 형평성, 지연 등을 모두 고려해 최고의 성능을 내게 한다.
 3)보호 : 고립과 관련된 것으로 프로세스를 보호하는 것.

6.프로세스 구성요소
 프로세스의 구성요소 중 가장 중요한 것은 명령어를 저장하는 메모리이다. 
 1)레지스터는 하드웨어의 상태를 저장하는 메모리로 어떤 명령어가 실행중인지 알려주는 PC(IP), 스택을 관리할 때 사용하는 SP,FP 등이 있다.
 2)주소 공간 : 프로세스가 접근할 수 있는 메모리의 주소
 3)I/O 정보 : 현재 프로세스가 열어놓은 파일 리스트 등?

7.프로세스의 상태
프로그램(동작하지 않고 있는 상태)->프로세스(동작중인 프로그램)
=>프로그램 코드와 정적 데이터를 프로세스의 주소공간에 load하면서 시작한다. 코드와 데이터를 실행하기 위해서 스택과 힙을 생성,초기화 후, 파일 디스크립터를 이용해 입출력 관련 설정.

실행 상태(running) : 프로세스의 명령어 실행상태.
준비 상태(ready) : 프로세스가 실행될 준비가 되어 있지만 CPU에서 다른 프로세스가 진행중이여서 대기중.
대기 상태(blocked) : I/O등의 이벤트로 프로세스의 CPU 사용을 중단한 상태. 다른 프로세스가 CPU 점유 가능. 실행 중이던 프로세스가 대기 상태가 되면 ready상태 였던 프로세스가 CPU 점유. I/O등 이벤트가 끝나면 다시 대기 상태가 된다.

8.프로세스 생성,제어 프로토콜
 1)fork() 시스템 콜
  fork함수로 자식 프로세스를 생성한다. 자식 프로세스는 부모 프로세스의 메모리를 복사해 사용한다.
  



9.LDE(Limited Direct Execution)
Direct Execution은 프로그램을 직접적으로 CPU에서 실행시키는 방법이다. 제한이 없기 때문에 OS가 제어할 수 없다.제어가 불가능하면 프로세스간의 고립도 보장할 수 없고 프로세스의 점유를 제한할 수 없다. OS가 제어를 하기 위해 kernel mode와 user mode로 각각의 모드에서 실행할 수 있는 명령을 제한하는 방법이다. user mode는 하드웨어에 대한 접근권한에 제한이 있는 모드, kernel 모드는 OS가 시스템에 대한 모든 자원 접근이 가능한 모드. user mode가 제한된 동작을 하고 싶을 땐 OS에게 system call을 요청해 kernel mode로 진입해야한다. 
프로세스가 2개 이상인 경우를 생각해보자. A프로세스가 실행 중일 때, B 프로세스로 바꾸기 위해 문맥교환을 실행한다. 이 때 어떻게 운영체제가 CPU에 대한 제어권을 얻을까? 
 1. 프로세스가 자발적으로 system call요청. -> 오래걸리므로 reboot이 유리.
 2. 운영체제가 CPU 제어권을 획득.
1번의 경우는 user mode인 프로세스가 허용되지 않은 작업을 실행해 system call이 발생해 OS에게 제어권이 넘어가는 경우이다.
2번은 timer interrupt를 발생시켜 현재 실행중인 프로세스를 중단시킴->프로그램의 상태를 메모리에 저장->interrupt handler 실행.

운영체제가 CPU제어권을 획득한 후 프로세스를 계속할지 바꿀건지는 스케줄러에 의해 결정된다. 스케줄러가 전환을 결정하면 운영체제는 문맥교환을 실행한다. 문맥교환은 현재 실행 중인 프로세스의 레지스터 값을 스택에 저장하고,다음에 실행할 프로세스의 레지스터 값을 스택에서 복원하는 일이다.

interrupt 도중 다른 interrupt가 발생하면 어떡하지?
1)인터럽트 처리중엔 다른 인터럽트는 무시
2)interrupt의 우선순위를 줘서 순차적으로 처리하게 한다.
3)lock 기법을 이용한다. -> 최대한 순차적으로 처리할 수 있게 함.

10.LDE 프로토콜
1)운영체제에서 트랩 테이블을 초기화 한다.

2)CPU(하드웨어)는 나중을 위해 테이블의 주소를 기억한다.

3)사용자 프로세스를 처리하기 위해 return-from-trap을 이용해

  3-1.프로세스 목록에 항목 추가

  3-2.프로그램 메모리 할당

  3-3.프로그램을 메모리에 탑재

  3-4.argv를 스택에 저장

  3-5.레지스터와 pc를 스택에 저장

위 작업을 실행한다.

4)return-from-trap에 의해 사용자 모드로 이동,main문으로 분기.

5)main 실행, 시스템 콜 호출, trap 실행

6)운영체제는 시스템 콜을 처리하고,다시 return-from-trap 명령어를 사용해 사용자 모드로 돌아간다.

7)프로세스는 리턴, exit() 시스템을 호출해 다시 trap하고 종료


스케줄링의 비교 기준 : 성능,형평성

반환 시간 : 작업이 완료된 시각 - 작업이 도착한 시간
응답 시간 : 동작을 시작한 시간 - 작업이 도착한 시간

FIFO(비선점) : 선입선출. 작업시간이 굉장히 긴 작업이 먼저 들어올 경우엔 매우 비효율적.(호위효과)

SJF(비선점) : 작업시간이 짧은 것 먼저 처리. 모든 프로세스가 동시에 들어왔다는 가정하에서 가능. 
짧은 것을 먼저 처리하는 것이 반환 시간이 짧아지므로 효율이 좋다고 생각할 수 있다.
최적의 알고리즘이라 생각할 수 있다. 하지만 모든 작업의 도착시간이 동일하지 않을 경우를 생각해보자.
A(120초 걸림)가 먼저 도착하고,b(10초),c(10초)가 10초에 도착했을 때를 생각해보자.
해결방법은 문맥교환을한다. 타임임터럽트를 걸어 현재 진행중인 프로세스를 멈춘다.(STCF 방법임.)

STCF(최소 잔여시간 우선)(선점) : 현재 진행중인 작업의 남은 시간보다 새로 들어온 작업의 잔여 시간이 더 짧을 경우 진행중인 작업을 중단하고 새로 들어온 작업을 진행함.

RR : 일정 시간동안 작업 진행 후 다음 작업으로 전환. 작업이 실행되는 일정 시간을 타임 슬라이스라고 함.
타임 슬라이스는 인터럽트 주기의 배수로 설정. 타임 슬라이스를 너무 짧게 설정하면 문맥 교환 비용이 더 많이 발생하게 되므로 성능 측면에서 문제가 있다. RR은 응답시간은 좋지만, 반환시간이 좋지 않다.

MLFQ의 개념
여러 개의 큐로 구성되어 큐마다 다른 우선순위가 배정된다.큐 내에서는 RR 스케줄링이 적용됨. 프로세스의 특징에 따라 다른 큐에 배정이 된다. I/O를 반복적으로 인터럽트하는 경우 높은 우선순위에, CPU를 오래 점유하는 경우는 낮은 우선순위에 배정된다. 높은 우선순위가 실행되는 동안 낮은 우선순위의 프로세스들은 동작하지 못한다.
우선순위를 조정하기 위해 
1)작업이 시스템에 처음 진입하면 가장 높은 우선순위에 놓는다. 
2)큐에서 주어진 타임슬라이스를 모두 사용했지만 끝내지 못하면 낮은 우선순위로 내려간다.
3)타임 슬라이스가 끝나기 전에 CPU를 양도하면 우선순위를 유지한다.
위 3가지를 가정한다.

긴 작업시간을 가진 프로세스가 계속해서 동작 하다 짧은 작업시간을 가진 프로세스가 들어오면 우선순위에서 밀리므로 후자에게 CPU를 양보한다. 만약 후자가 진짜 짧은 작업시간을 가지고 있었다면 마지막 우선순위까지 오기 전에 끝날 것이다.

입출력이 있는 프로세스의 경우엔 CPU를 양도하므로 우선순위가 유지된다. 

MLFQ의 문제점
1)기아 문제
대화형 작업이 존재하면 이 작업이 높은 우선순위를 차지하고 있기 때문에 우선순위가 낮은 작업은 진행이 더디다.
-> 일정 시간(부두 상수)이 지나면 모든 작업을 최상위 큐로 올리는 방법으로 해결.

2)스케줄러를 자신에게 유리하도록 다시 작성할 수 있다.
타임 슬라이스가 끝나기 전에 입출력 요청을 보내 우선순위를 유지하여 CPU를 독점하게 된다.
->각 단계에서 CPU 총 사용시간을 측정한다. 작업이 소진할 수 있는 CPU 사용시간을 정해 두고 그 이상 사용 시 우선순위를 강등시킨다. 



11.고립의 중요성

12.principle of isolation 
 각 프로세스간에 피해를 주지않도록 하는 원칙으로, 다른 운영체제에도 플러그인처럼 적용이 가능하다.

13.double free
 free함수를 여러 번 호출해 발생하는 에러

14.dangling pointer
 포인터에 아무것도 안달려 있는 상태의 에러

15.How can we achive dynamic (hardware-based) relocation? Explain in brief.

 

-동적 리로케이션을 위해 필요한 점.

1.privileged mode

  - 프로텍션을 위해서 필요함.

 - base bound register 값을 맘대로 변경하지 못하게 하기 위해서.

2.base/bound register

CPU별로 하나씩 필요

3.ability to translate virtual address and check if within bound

하드웨어가 가상주소를 바꾸고 결과가 bound 주소 내에 있는지 확인해야 함.

4.privileged instruction to register exception handler

 - 예외처리를 위한 특권 명령어

5.ability to raise exception

 - base bound를 넘었을 때 예외 처리를 위해서.



세그멘테이션
Fine-grained segmentation : 세그먼트의 크기를 제한하지 않음.

coarse-grained segmentation : 대충 대충 넓게 세그먼트를 잡음.


external fragmentation : 필요에 맞춰 공간을 할당 했는데 중간중간 비어있는 부분이 있을 수 있음.
best fit : 요청을 받은 세그먼트에 맞춰 끼워넣음.

worst fit : 가장 큰 공간을 먼저 할당.

first fit : 제일 처음 발견된 공간을 바로 배치. 빠른 응답에 좋음.


buddy algorithm

메모리를 최대한 요구에 맞춰(best fit) 나누어준다. 

내부 단편화 문제가 남아있다. 
내부 단편화는 4kb중 3kb를 사용해 남은 1kb를 사용할 수 없는 것.



free space management
1.best fit(smallest fit)

free list를 서치하면서 요청된 사이즈보다 큰 것들 중 가장 작은 것을 할당함.

처음부터 끝까지 free list를 모두 확인하기 때문에 시간 복잡도 증가.

 

2.worst fit

현존하는 가장 큰 청크를 찾아 요청된 사이즈 만큼 리턴하고 나머지는 free list에 반납.

8kb로 나눠진 메모리가 있는데 7kb만큼 씩 요청할 경우 1kb씩 free list에 남게된다. 이렇게 작은 청크만 free list에 남게되고, 탐색 시간이 증가하게 된다.

worst fit에 경우 할당하고 남은 양이 커서 다음 요청에서도 재활용될 수 있기 때문에 조금 더 효율적일 수 있음.

요청하는 양에 따라 best fit worst fit 차이가 있음.

free list를 모두 탐색해야 함.  그렇게 좋은 퍼포먼스를 보이지 않음. 

 

3.first fit

요청을 받은 후 처음으로 크기를 만족하는 free list를 리턴. 시간 복잡도가 낮음. 역시 작은 크기의 free list가 계속 생성될 수 있음. 시간이 지날 수록 시간 복잡도가 낮은 장점이 사라짐.

address based ordering : free space의 주소를 바탕으로 list를 정렬, 통합을 쉽게 함. fregmentation을 줄일 수 있음. -> 단점이 해결될 수 있음.

 

4.next fit

링크드 리스트에서 사용하고 남은 공간에 포인터를 할당, 다음에 요청이 발생 시 포인터 부터 탐색 시작. first fit의 단점을 커버할 수 있음. 

전체 탐색을 다시 하지 않아도 됨.

5.buddy allocation
coalescing을 단순하게 해줌.

free memory는 2의n승의 형태로 되어 있음. 요청의 크기에 맞을 때까지 free space를 계속해서 2로 나눔. 중요한 점은 합치는 것을 좀 더 편하게 해준다는 점이다. 크기에 맞춰 나눠 배정을 한 후, 남은 쪽(buddy)이 free한 상태인지 확인. 맞으면 병합. 위에서도 buddy가 free한지 확인. 병합 과정을 재귀적으로 구현. 특정한 비트의 차이만으로 확인 가능. 
